<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用 RxSwift 为 Controller 瘦身(1)，优雅的使用网络请求(Moya) + 数据缓存(Cache)</title>
      <link href="/2019/02/13/yong-rxswift-wei-controller-shou-shen-1-you-ya-de-shi-yong-wang-luo-qing-qiu-moya-shu-ju-huan-cun-cache/"/>
      <url>/2019/02/13/yong-rxswift-wei-controller-shou-shen-1-you-ya-de-shi-yong-wang-luo-qing-qiu-moya-shu-ju-huan-cun-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>View Controller 向来是 MVC (Model-View-View Controller) 中最让人头疼的一环，MVC 架构本身并不复杂，但开发者很容易将大量代码扔到用于协调 View 和 Model 的 Controller 中。你不能说这是一种错误，因为 View Controller 所承担的本来就是胶水代码和业务逻辑的部分。但是，持续这样做必定将导致 Model View Controller 变成 Massive View Controller，代码也就一天天烂下去，直到没人敢碰。</p></blockquote><p>写到后来，几经变换，最后你的 Controller 常常就变成了这样<br><img src="https://upload-images.jianshu.io/upload_images/2568859-e05be7f19115007e.gif?imageMogr2/auto-orient/strip" alt=""></p><p>Controller 中含有大量代码的一个很大原因在于，大多数人都误用了 <strong>MVC</strong>，推荐可以看看喵神的这两篇文章，深入浅出。<br><a href="https://onevcat.com/2018/05/mvc-wrong-use/" target="_blank" rel="noopener">关于 MVC 的一个常见的误用</a><br><a href="https://onevcat.com/2017/07/state-based-viewcontroller/" target="_blank" rel="noopener">单向数据流动的函数式 View Controller</a></p><p>这篇文章我们先从网络层入手，在 <strong>iOS</strong> 开发中，网络请求与数据解析可以说是其中占比很高并且不可分割的一部分。</p><p>身为一名 <strong>iOS</strong> 开发，也许你不知道 <code>NSUrlConnection</code>、也不知道 <code>NSURLSession</code>，但你一定知道  <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a> / <a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>。对他们你肯定也做过一些自己的封装，或者直接采用业内比较知名的第三方封装。比如 <strong>Objective-C</strong> 中的 <a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a> ，<strong>Swift</strong> 中的 <a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> 等等。</p><p>那么问题来了，无论是自己封装也好还是直接采用第三方也好，在我们熟知的 <strong>MVC</strong> 模式中，你依旧需要在 Controller 中回调 Block / Delegate 对其做出处理，比如对返回数据的校验与解析，对指示器的控制，对刷新控件的控制，把 Model 赋值给 View 等等。而且在 <strong>iOS 中</strong> Controller 本身就包含了一个 View，对其生命周期的管理和界面布局无疑又增加了 Controller 的负担。</p><p>久而久之，当控制器中再加入一些其他的业务逻辑时，整个控制器里的代码就会变得非常臃肿，巨胖无比，随着业务的变更，代码的可读性会变得很差。其实 Controller 中大多数代码都可以被抽离出去，比如说我们的网络请求。</p><h1 id="让网络请求的代码更优雅"><a href="#让网络请求的代码更优雅" class="headerlink" title="让网络请求的代码更优雅"></a>让网络请求的代码更优雅</h1><p>本篇文章我们主要是针对 <a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> 的再次封装扩展。其实 <a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> 本身对网络层的封装已经很优秀了，自带了对于 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 这类函数响应式库的扩展，网络层非常清晰，并且提供了简单方便的网络单元测试。但我们依然可以把她变得更好。</p><h3 id="封装-Moya"><a href="#封装-Moya" class="headerlink" title="封装 Moya"></a>封装 Moya</h3><p><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> 的使用我在这里就不贴了，没用过的小伙伴可以去官方文档学习一下。</p><p>用过的小伙伴知道，我们使用 Moya 都要先创建一个 <code>Enum</code> 遵守 <code>TargetType</code> 协议实现对应的方法（比如指定请求的 URL 路径，参数等等）。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token builtin">GitHub</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">GitHub</span><span class="token punctuation">:</span> <span class="token builtin">TargetType</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">var</span> baseURL<span class="token punctuation">:</span> <span class="token constant">URL</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">URL</span><span class="token punctuation">(</span>string<span class="token punctuation">:</span> <span class="token string">"https://api.github.com"</span><span class="token punctuation">)</span><span class="token operator">!</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">var</span> path<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token keyword">let</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"/users/<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token punctuation">.</span>urlEscaped<span class="token delimiter variable">)</span></span>"</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">var</span> method<span class="token punctuation">:</span> <span class="token builtin">Moya</span><span class="token punctuation">.</span><span class="token builtin">Method</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token keyword">get</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">var</span> task<span class="token punctuation">:</span> <span class="token builtin">Task</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">.</span>requestPlain        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>而实际的请求是使用 <code>MoyaProvider&lt;Target&gt;</code> 类，传入一个遵守 <code>TargetType</code> 协议的 <code>Enum</code>，创建 <code>MoyaProvider</code> 对象去请求的。</p><pre class=" language-swift"><code class="language-swift">provider <span class="token operator">=</span> <span class="token builtin">MoyaProvider</span><span class="token operator">&lt;</span><span class="token builtin">GitHub</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>provider<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> result <span class="token keyword">in</span>    <span class="token comment" spellcheck="true">// do something with the result</span><span class="token punctuation">}</span></code></pre><p>可是如果把项目中所有的网络请求都写在同一个 <code>Enum</code> 中的话，这个<code>Enum</code>里的代码会非常多，维护起来也并不方便。</p><p>笔者在使用时通常都是根据模块创建多个 <code>Enum</code>，比如按首页模块，新闻模块这样划分。如果这么写的话，我们创建 <code>MoyaProvider</code> 对象时就不能再传入指定类型的 <code>Enum</code> 了。我们把创建对象的写法改成 <code>MoyaProvider&lt;MultiTarget&gt;</code>，所有传入的 <code>Enum</code> 得用 <code>MultiTarget</code> 包装一层。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> provider <span class="token operator">=</span> <span class="token builtin">MoyaProvider</span><span class="token operator">&lt;</span><span class="token builtin">MultiTarget</span><span class="token operator">></span>provider<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token function">MultiTarget</span><span class="token punctuation">(</span><span class="token builtin">GitHub</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> result <span class="token keyword">in</span>    <span class="token comment" spellcheck="true">// do something with the result</span><span class="token punctuation">}</span></code></pre><p>看了上面的代码，好像已经开始变得不那么优雅了，我指定一个请求竟然要写这么多代码，一大堆括号看的眼睛都晕。能不能直接使用 <code>Enum</code> 的类型不需要借助 <code>MoyaProvider</code> 对象去请求呢，类似这样的效果。</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">GitHub</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>request</code></pre><p>以下封装我们基于 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 来实现，当然如果你不熟悉 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 也没关系，这里只是对封装思路的介绍，封装完成以后可以直接使用，等以后熟悉了 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 再回头看也行。以下文章的思路大多借鉴 <a href="https://github.com/Pircate/RxNetwork" target="_blank" rel="noopener">RxNetwork</a> 这个库的实现。</p><p>首先我们为 <code>TargetType</code> 添加自己的 <code>public extension</code> 方便外界调用。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">extension</span> <span class="token builtin">TargetType</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>先实现一个可以直接使用 <code>Enum</code> 类型调用请求的方法。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> provider <span class="token operator">=</span> <span class="token builtin">MoyaProvider</span><span class="token operator">&lt;</span><span class="token builtin">MultiTarget</span><span class="token operator">></span><span class="token keyword">public</span> <span class="token keyword">extension</span> <span class="token builtin">TargetType</span> <span class="token punctuation">{</span>   <span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Single</span><span class="token operator">&lt;</span><span class="token builtin">Response</span><span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> provider<span class="token punctuation">.</span>rx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个方法返回一个 <code>Single</code> 类型的  <code>Observable</code> 。<code>Single</code> 是 <code>Observable</code> 的另一个版本。它不像 <code>Observable</code> 可以发出多个元素，它要么只能发出一个元素，要么产生一个 <code>error</code> 事件，不共享状态变化，用来做请求的返回非常合适。</p><p> 写完我们就可以直接用 <code>Enum</code> 调用请求，怎么样是不是非常简单呢。代码的可读性也变高了很多。对请求的结果只需要调用 <code>subscribe</code> 去监听即可。</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">GitHub</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>request<span class="token punctuation">.</span>subscribe<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="封装-JSON-解析"><a href="#封装-JSON-解析" class="headerlink" title="封装 JSON 解析"></a>封装 JSON 解析</h3><p>先回顾一下我们以往的 JSON 解析，通常都是使用第三方解析库，直接把代码放到每次请求的回调中去处理。</p><p>乍一看其实没毛病，那么这么做有什么弊端呢？其实这种写法侵入性很强，试想一下假如有一天你这个第三方解析库不维护了，或者种种原因你需要更换到其他的第三方，或者自己手写解析，那么你需要替换和修改的地方就非常多。</p><p>你可能会说，那我可以在第三方解析的方法上封装一层，然后调用我自己的解析方法啊。是的，想法很好，但你有没有想过其实解析的写法可以变得非常优雅。</p><p> <a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> 自身就提供了基于 <code>Codable</code> 协议的原生解析方法。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token builtin">map</span><span class="token operator">&lt;</span>D<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> type<span class="token punctuation">:</span> D<span class="token punctuation">.</span><span class="token keyword">Type</span><span class="token punctuation">,</span> atKeyPath keyPath<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">,</span> using decoder<span class="token punctuation">:</span> <span class="token builtin">JSONDecoder</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">,</span> failsOnEmptyData<span class="token punctuation">:</span> <span class="token builtin">Bool</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> D <span class="token keyword">where</span> D <span class="token punctuation">:</span> <span class="token builtin">Decodable</span></code></pre><p>支持对 <strong>JSON</strong> 指定路径的解析，实现的原理也非常简单，感兴趣的小伙伴可以去源码中学习一下。具体位置在 <code>Response</code> 这个类中搜索关键词即可。<br>这个方法我们直接就能使用，转模型的代码可以写成这样</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">GitHub</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token builtin">UserModel</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span></code></pre><p>当然最好我们还是在原生方法上再封装一层，减少原生方法对项目的侵入性。</p><p>需要注意的是，在我们平时使用 <code>Codable</code> 协议时，通常都要分清解析的是数组还是字典。如果是数组类型数据的话，必须得调用指定解析数组的方法，否则无法正确解析。</p><p>但 <a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> 是可以在外界直接传入数组类型的，具体实现也非常简单。用一个 <code>Struct</code> 的结构体去包装每次需要解析的对象，再把解析对象指定为包装好的结构体。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">private</span> <span class="token keyword">struct</span> <span class="token builtin">DecodableWrapper</span><span class="token punctuation">:</span> <span class="token builtin">Decodable</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> value<span class="token punctuation">:</span> T<span class="token punctuation">}</span></code></pre><p>这样就不用关心外界需要解析的具体类型，相当于每次解析的必然是一个包装好的字典类型，最后只要把结构体里的 <code>value</code> 返回就行。</p><p>扯一个题外话，那这种实现思路在 <strong>Objective-C</strong>  中是否可行呢，可以思考如下两个问题。</p><ol><li>在 <strong>Objective-C</strong> 中我们使用 <a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a> / <a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel</a>  这些库去解析 <strong>JSON</strong> 时，都要调用指定的解析方法(数组和字典的解析方法是不同的)，能否用以上的思路把解析数组和解析字典的方法整合成一个方法呢？</li><li>如果要解析的模型中有个数组属性，数组里面又要装着其他模型。还要写指定数组内部类型的方法。</li></ol><ul><li><p><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a></p><pre class=" language-objective-c"><code class="language-objective-c">// Tell MJExtension what type of model will be contained in statuses and ads.[StatusResult mj_setupObjectClassInArray:^NSDictionary *{  return @{             @"statuses" : @"Status",             // @"statuses" : [Status class],             @"ads" : @"Ad"             // @"ads" : [Ad class]         };}];</code></pre></li><li><p><a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel</a><br><code>`</code> objective-c</p></li></ul><ul><li>(NSDictionary *)modelContainerPropertyGenericClass {<br>  // value should be Class or Class name.<br>  return @{@”shadows” : [Shadow class],<pre><code>       @&quot;borders&quot; : Border.class,       @&quot;attachments&quot; : @&quot;Attachment&quot; };</code></pre>}<br><code>`</code></li></ul><p>这么写目的是为了在运行时拿到数组中元素的具体类型，再用 <code>Runtime</code> 去类中获取属性以及 <code>KVC</code> 赋值。如果用泛型指定数组里元素的具体类型的话，这些方法是否可以省略呢？</p><p>然而很遗憾，原生的 <strong>Objective-C</strong> 是无法实现以上想法的。原因在于 <strong>Objective-C</strong> 的泛型只能算是”伪”泛型，仅仅是一个编译器特性，只能在编译时为 <strong>Xcode</strong> 提供具体类型，在运行时是没有的。</p><h3 id="封装网络缓存"><a href="#封装网络缓存" class="headerlink" title="封装网络缓存"></a>封装网络缓存</h3><p>为了提升用户体验，在实际开发中，有一些内容可能会加载很慢，我们想先显示上次的内容，等加载成功后，再用最新的内容替换上次的内容。也有时候，由于网络处于断开状态，为了更加友好，我们想显示上次缓存中的内容。</p><p>网络缓存我们基于 <a href="https://github.com/hyperoslo/Cache" target="_blank" rel="noopener">Cache</a> 来实现。首先创建一个 <code>CacheManager</code> 统一处理所有的读取和存储操作。我们把读取模型数据和读取网络请求返回的 <code>Response</code> 数据分别创建不同的方法（这里只贴了模型的方法）。</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// MARK: - 读取模型缓存</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> object<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Codable</span><span class="token operator">></span><span class="token punctuation">(</span>ofType type<span class="token punctuation">:</span> T<span class="token punctuation">.</span><span class="token keyword">Type</span><span class="token punctuation">,</span> forKey key<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T<span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> storage <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">Storage</span><span class="token punctuation">(</span>diskConfig<span class="token punctuation">:</span> <span class="token function">DiskConfig</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"NetObjectCache"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> memoryConfig<span class="token punctuation">:</span> <span class="token function">MemoryConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transformer<span class="token punctuation">:</span> <span class="token builtin">TransformerFactory</span><span class="token punctuation">.</span><span class="token function">forCodable</span><span class="token punctuation">(</span>ofType<span class="token punctuation">:</span> type<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">try</span> storage<span class="token punctuation">.</span><span class="token function">removeExpiredObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">try</span> storage<span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span>forKey<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token constant">nil</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// MARK: - 缓存模型</span>    <span class="token keyword">static</span> <span class="token keyword">func</span> setObject<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Codable</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> object<span class="token punctuation">:</span> T<span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> storage <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">Storage</span><span class="token punctuation">(</span>diskConfig<span class="token punctuation">:</span> <span class="token function">DiskConfig</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"NetCache"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> memoryConfig<span class="token punctuation">:</span> <span class="token function">MemoryConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transformer<span class="token punctuation">:</span> <span class="token builtin">TransformerFactory</span><span class="token punctuation">.</span><span class="token function">forCodable</span><span class="token punctuation">(</span>ofType<span class="token punctuation">:</span> T<span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">try</span> storage<span class="token punctuation">.</span><span class="token function">setObject</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> forKey<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span>  <span class="token punctuation">{</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"error<span class="token interpolation"><span class="token delimiter variable">\(</span>error<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>缓存的方法封装好以后，我们还需要知道缓存的 <strong>key</strong>，这里我们采用请求的 URL + 参数拼接成 <strong>key</strong>。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">Task</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">var</span> parameters<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">requestParameters</span><span class="token punctuation">(</span><span class="token keyword">let</span> parameters<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>parameters<span class="token delimiter variable">)</span></span>"</span>        <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">requestCompositeData</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">,</span> <span class="token keyword">let</span> urlParameters<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>urlParameters<span class="token delimiter variable">)</span></span>"</span>        <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">requestCompositeParameters</span><span class="token punctuation">(</span>bodyParameters<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> urlParameters<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>bodyParameters<span class="token delimiter variable">)</span></span><span class="token interpolation"><span class="token delimiter variable">\(</span>urlParameters<span class="token delimiter variable">)</span></span>"</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">""</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">extension</span> <span class="token builtin">TargetType</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> cachedKey<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">URL</span><span class="token punctuation">(</span>target<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">.</span>absoluteString<span class="token delimiter variable">)</span></span>?<span class="token interpolation"><span class="token delimiter variable">\(</span>task<span class="token punctuation">.</span>parameters<span class="token delimiter variable">)</span></span>"</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>万事俱备，现在为 <code>TargetType</code> 添加一个 <code>cache</code> 属性，返回一个 <code>Observable</code> 包装遵守 <code>TargetType</code> 协议的 <code>Enum</code> 。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> cache<span class="token punctuation">:</span> <span class="token builtin">Observable</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token builtin">Observable</span><span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>那么我们调用缓存的代码就变成了这样</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">GitHub</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache</code></pre><p>但是这个缓存还没有具体的实现，现在我们为缓存添加实现，只有遵守 <code>TargetType</code> 协议才能调用。</p><p>每次调用方法都把请求结果缓存到本地，返回数据时先从本地获取，本地没有值时只返回网络数据。这里的 <code>startWith</code> 保证本地数据有值时，本地数据每次都优先在网络数据之前返回。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">ObservableType</span> <span class="token keyword">where</span> E<span class="token punctuation">:</span> <span class="token builtin">TargetType</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Observable</span><span class="token operator">&lt;</span><span class="token builtin">Response</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> flatMap <span class="token punctuation">{</span> target <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Observable</span><span class="token operator">&lt;</span><span class="token builtin">Response</span><span class="token operator">></span> <span class="token keyword">in</span>            <span class="token keyword">let</span> source <span class="token operator">=</span> target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">storeCachedResponse</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token keyword">let</span> response <span class="token operator">=</span> target<span class="token punctuation">.</span>cachedResponse <span class="token punctuation">{</span>                <span class="token keyword">return</span> source<span class="token punctuation">.</span><span class="token function">startWith</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> source        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>现在我们的缓存已经初步完成了，在 onNext 回调中，第一次返回的是本地数据，第二次是网络数据。我们的请求就变成了这样</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">GitHub</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token builtin">UserModel</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subscribe <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>这样的好处是，每个方法之间都是独立的，我不想要缓存我只要去掉 <code>cache</code> 不想转模型只要去掉 <code>map</code> ，整段代码的可读性变得很强。</p><p>由于 RxSwift 的存在，你也不需要在 Controller 销毁时去手动管理网络请求的取消。你想做一些网络的其他高级操作也变得非常容易，比如说链式的网络请求，group 式的网络请求，请求失败自动重试，同一个请求多次请求时短时间忽略相同的请求等等都非常简单。</p><p>现在回头看看我们的需求，优先展示本地数据，网络数据返回时自动替换本地数据，网络请求失败时加载本地数据。</p><p>但是这种写法应用场景相对比较单一，只能适用于本地数据和网络数据的处理是相同的情况。我们在 <code>onNext</code> 中无法区分本地数据和网络数据，假如想对本地数据做一些特殊处理的话是不行的。<br>我们再完善一下代码，将本地数据的回调告诉外界。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> onCache<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Codable</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> type<span class="token punctuation">:</span> T<span class="token punctuation">.</span><span class="token keyword">Type</span><span class="token punctuation">,</span> atKeyPath keyPath<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">_</span> onCache<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">OnCache</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token keyword">let</span> object <span class="token operator">=</span> <span class="token function">cachedObject</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>onCache<span class="token operator">?</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">OnCache</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>返回的 <code>OnCache</code> 对象是自定义的一个结构体</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token builtin">OnCache</span><span class="token operator">&lt;</span><span class="token builtin">Target</span><span class="token punctuation">:</span> <span class="token builtin">TargetType</span><span class="token punctuation">,</span> T<span class="token punctuation">:</span> <span class="token builtin">Codable</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">let</span> target<span class="token punctuation">:</span> <span class="token builtin">Target</span>    <span class="token keyword">public</span> <span class="token keyword">let</span> keyPath<span class="token punctuation">:</span> <span class="token builtin">String</span>    <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token number">_</span> target<span class="token punctuation">:</span> <span class="token builtin">Target</span><span class="token punctuation">,</span> <span class="token number">_</span> keyPath<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target        <span class="token keyword">self</span><span class="token punctuation">.</span>keyPath <span class="token operator">=</span> keyPath    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Single</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">mapObject</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">,</span> atKeyPath<span class="token punctuation">:</span> keyPath<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">storeCachedObject</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> target<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>现在我们就可以在 <code>onCache</code> 的回调中拿到本地数据了，如果你想对本地数据做一些自己的操作和处理的话，选择第二种方案会更加合适。后续的 <code>subscribe</code> 监听到的是一个 <code>Single</code> ，如之前所说，只会返回成功或者失败，这里我们只把网络数据返回就好。这样就做到了网络数据和本地数据的区分。</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">GitHub</span><span class="token punctuation">.</span><span class="token function">userProfile</span><span class="token punctuation">(</span><span class="token string">"InsectQY"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onCache</span><span class="token punctuation">(</span><span class="token builtin">UserModel</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>local<span class="token punctuation">)</span> <span class="token keyword">in</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subscribe <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了看了以上这么多，我们只是对网络层做了一些封装，还没有做这种写法实际在项目中的应用，后续将教大家如何用 <code>RxSwift</code> 减少控制器的代码。</p><p>具体的 <code>demo</code> 和用法可以查看我开源的这个项目 <strong><a href="https://github.com/InsectQY/GamerSky" target="_blank" rel="noopener">GamerSky</a></strong><br>或者原作者的  <a href="https://github.com/Pircate/RxNetwork" target="_blank" rel="noopener">RxNetwork</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxSwift </tag>
            
            <tag> Moya </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零基础也能看懂的 RxSwift 官方 Example 解析(1) Bindings</title>
      <link href="/2019/02/13/ling-ji-chu-ye-neng-kan-dong-de-rxswift-guan-fang-example-jie-xi-1-bindings/"/>
      <url>/2019/02/13/ling-ji-chu-ye-neng-kan-dong-de-rxswift-guan-fang-example-jie-xi-1-bindings/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>很多小伙伴在初学 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 时，在面对大量的操作符和各种抽象的概念时可能都会感到无从下手，但其实官方提供的 Example 就能够很方便的帮助我们学习 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 的各种概念以及如何与 MVVM 相结合。毕竟直接看实际的运用场景比看抽象的概念要容易理解的多。</p><p>我个人认为 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 的核心其实很简单，就是把要操作的事件、属性都抽象成一个个<code>Observable</code>，剩下的变换、组合、过滤、响应(订阅)、线程调度、生命周期管理都是你对 <code>Observable</code> 的加工和处理。如果你真的理解了什么是 <code>Observable</code>，哪些东西可以被包装成 <code>Observable</code> 那么你已经成功了一半啦，就像你刚学面向对象编程，搞懂了什么是对象，哪些东西可以被抽象成对象以后，后面的学习是不是顺利了很多呢。</p><p>其实初学的时候真的不用在面对大量的操作符时困惑，也不要有怕难的心态，觉得这么多东西我得记到什么时候。可以先看一遍文档有能力的也可以看看源码。用的多了你会发现和我们平常写代码一样，常用的 Api 就那些，其他用的少的真忘记的时候再翻翻文档就好。(中文文档 <a href="https://github.com/beeth0ven/RxSwift-Chinese-Documentation" target="_blank" rel="noopener">RxSwift-Chinese-Documentation</a>)</p><p>好了废话不多说，本篇所有示例代码在 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 官方项目中就有，下载完了直接运行即可。<img src="https://upload-images.jianshu.io/upload_images/2568859-26d17f069a8bd03c.gif?imageMogr2/auto-orient/strip" alt=""></p><p>可以看到官方为我们分了三块内容，</p><ul><li>iPhone Example</li><li>TableView 和 CollectionView Example</li><li>综合的 Example</li></ul><p>本篇文章我们先从这些 Demo 里最简单的 Bindings 说起。</p><h1 id="Adding-numbers"><a href="#Adding-numbers" class="headerlink" title="Adding numbers"></a>Adding numbers</h1><p>先看运行效果<img src="https://upload-images.jianshu.io/upload_images/2568859-16a4f1bc0c762c44.gif?imageMogr2/auto-orient/strip" alt=""></p><p>有三个 <code>UITextField</code> 任何一个 <code>UITextField</code> 输入内容时，把三者相加，在最底部 <code>UILabel</code> 显示结果。</p><p>这是一个很简单的响应式编程的例子，这个页面主要由四个元素组成</p><pre class=" language-swift"><code class="language-swift"><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> number1<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> number2<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> number3<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> result<span class="token punctuation">:</span> <span class="token builtin">UILabel</span><span class="token operator">!</span></code></pre><p>先考虑一下以往我们会怎么实现：</p><ol><li>监听三个  <code>UITextField</code>  的文本框改变(<code>Delegate</code>、<code>KVO</code>、<code>NSNotificationCenter</code>、<code>addTarget</code>)。</li><li>在回调方法中将三个 <code>UITextField</code> 输入内容转成 <code>Int</code> 相加并赋值给 <code>UILabel</code>。</li></ol><p>原生实现最大的问题在于，无论哪种方式，监听文本框内容改变的代码都不是那么的优雅。</p><p>看一下用 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 如何实现。回想我们刚刚所说的核心，把属性或者事件抽象成 <code>Observable</code>，再对 <code>Observable</code> 进行操作。</p><ol><li>包装 (把三个 <code>UITextField</code> 输入的内容抽象成三个 <code>Observable</code>)<pre class=" language-swift"><code class="language-swift">number1<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmptynumber2<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmptynumber3<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmpty</code></pre></li><li>组合 (把三个 <code>Observable</code> 组合，并将每一个值转成 <code>Int</code> 类型相加)。<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Observable</span><span class="token punctuation">.</span><span class="token function">combineLatest</span><span class="token punctuation">(</span>number1<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmpty<span class="token punctuation">,</span> number2<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmpty<span class="token punctuation">,</span> number3<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span> textValue1<span class="token punctuation">,</span> textValue2<span class="token punctuation">,</span> textValue3 <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token keyword">in</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">Int</span><span class="token punctuation">(</span>textValue1<span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">Int</span><span class="token punctuation">(</span>textValue2<span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">Int</span><span class="token punctuation">(</span>textValue3<span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>文档中为我们描述的 <code>combineLatest</code> 的作用。<blockquote><p>当多个 Observables 中任何一个发出一个元素，就发出一个元素。这个元素是由这些 Observables 中最新的元素，通过一个函数组合起来的。<br><img src="https://upload-images.jianshu.io/upload_images/2568859-8c64061a2a4119e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></blockquote></li></ol><p>说的再直白一点就是，这三个  <code>UITextField</code> 任意一个有新值的时候都会被组合成新的<code>Observable</code>。</p><ol start="3"><li>转换 (把 <code>Int</code> 类型转换成 <code>String</code> 类型)<pre class=" language-swift"><code class="language-swift"><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span>description <span class="token punctuation">}</span></code></pre></li><li>响应 (把值绑定到 <code>UILabel</code>)<pre class=" language-swift"><code class="language-swift"><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> result<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">)</span></code></pre></li><li>管理生命周期<pre class=" language-swift"><code class="language-swift"><span class="token punctuation">.</span><span class="token function">disposed</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> disposeBag<span class="token punctuation">)</span></code></pre>怎么样是不是很简单呢，只需要6行代码我们就完成了这个需求。</li></ol><h1 id="SimpleValidation"><a href="#SimpleValidation" class="headerlink" title="SimpleValidation"></a>SimpleValidation</h1><p>运行效果<br><img src="https://upload-images.jianshu.io/upload_images/2568859-af4eda21d2cc3d77.gif?imageMogr2/auto-orient/strip" alt=""></p><ul><li>当用户输入用户名时，如果用户名不足 5 个字就显示红色提示语，并且无法输入密码，当用户名符合要求时才可以输入密码。</li><li>同样的当用户输入的密码不到 5 个字时也显示红色提示语。</li><li>当用户名和密码有一个不符合要求时底部的绿色按钮不可点击，只有当用户名和密码同时有效时按钮才可点击。</li><li>当点击绿色按钮后弹出一个提示框</li></ul><p>页面由以下元素组成</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/// 用户名</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> usernameOutlet<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span><span class="token comment" spellcheck="true">/// 用户名红色提示语</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> usernameValidOutlet<span class="token punctuation">:</span> <span class="token builtin">UILabel</span><span class="token operator">!</span><span class="token comment" spellcheck="true">/// 密码</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> passwordOutlet<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span><span class="token comment" spellcheck="true">/// 密码红色提示语</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> passwordValidOutlet<span class="token punctuation">:</span> <span class="token builtin">UILabel</span><span class="token operator">!</span><span class="token comment" spellcheck="true">/// 按钮</span><span class="token atrule">@IBOutlet</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> doSomethingOutlet<span class="token punctuation">:</span> <span class="token builtin">UIButton</span><span class="token operator">!</span></code></pre><p>还是先考虑一下以往我们会怎么实现：</p><ol><li>监听两个  <code>UITextField</code>  的文本框改变(<code>Delegate</code>、<code>KVO</code>、<code>NSNotificationCenter</code>、<code>addTarget</code>)。</li><li>在回调方法中判断用户名是否符合要求，用判断结果去设置提示语是否隐藏和密码框是否可以输入。</li><li>在回调方法中判断密码是否符合要求，用判断结果去设置提示语是否隐藏。</li><li>拿到前两个判断的结果，当前两个的结果都为真时，按钮可以点击。</li><li>添加按钮点击事件。</li></ol><p>看一下用 <a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a> 如何实现。还是我们刚刚所说的核心，把属性或者事件抽象成 <code>Observable</code>，再对 <code>Observable</code> 进行操作。</p><ol><li>用户名格式是否正确 (变换)<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> usernameValid <span class="token operator">=</span> usernameOutlet<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmpty<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">>=</span> minimalUsernameLength <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span>replay<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre></li><li>密码格式是否正确 (变换)<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> passwordValid <span class="token operator">=</span> passwordOutlet<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>text<span class="token punctuation">.</span>orEmpty<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">>=</span> minimalPasswordLength <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span>replay<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre></li><li>两者都正确(组合 ，<code>combineLatest</code> 作用上面介绍过，再巩固一下)<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> everythingValid <span class="token operator">=</span> <span class="token builtin">Observable</span><span class="token punctuation">.</span><span class="token function">combineLatest</span><span class="token punctuation">(</span>usernameValid<span class="token punctuation">,</span> passwordValid<span class="token punctuation">)</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">&amp;&amp;</span> $<span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span>replay<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre>这里你可能比较疑惑这个 <code>.share(replay: 1)</code> 是干嘛的。</li></ol><p>通俗一点说，当有多个订阅者去订阅同一个 <code>Observable</code> 的时候，我们不希望 <code>Observable</code> 每次有新的订阅者都去执行。</p><ol start="4"><li>响应</li></ol><pre class=" language-swift"><code class="language-swift">usernameValid<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> passwordOutlet<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>isEnabled<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disposed</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> disposeBag<span class="token punctuation">)</span></code></pre><pre class=" language-swift"><code class="language-swift">usernameValid<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> usernameValidOutlet<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>isHidden<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disposed</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> disposeBag<span class="token punctuation">)</span></code></pre><pre class=" language-swift"><code class="language-swift">passwordValid<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> passwordValidOutlet<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>isHidden<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disposed</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> disposeBag<span class="token punctuation">)</span></code></pre><pre class=" language-swift"><code class="language-swift">everythingValid<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> doSomethingOutlet<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>isEnabled<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disposed</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> disposeBag<span class="token punctuation">)</span></code></pre><p>由于 <code>.share(replay: 1)</code> 的存在，这个判断密码或者用户名是否合法的操作，不管以后被多少人订阅，只会判断一次，这样可以避免不必要的资源消耗。</p><ol start="5"><li>按钮添加点击事件<pre class=" language-swift"><code class="language-swift">doSomethingOutlet<span class="token punctuation">.</span>rx<span class="token punctuation">.</span>tap<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>onNext<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token number">_</span> <span class="token keyword">in</span> <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">showAlert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disposed</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> disposeBag<span class="token punctuation">)</span></code></pre>当然这步我们是可以通过扩展的方式让他更加优雅的，这篇我们不做过多讲解。</li></ol><p>最后说句题外话，学东西还是要从简单的学起，这样会多一些正面积极的反馈，就像是打游戏总会一段时间就有一个小的奖励，刺激你继续玩下去。如果一上来就看大量的操作符，各种概念和源码，挫败感一大就不想学了。</p><p>下一篇将更新如何与 MVVM 结合做一个 GitHub 的注册界面。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxSwift </tag>
            
            <tag> Swift </tag>
            
            <tag> Bindings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 iOS 上实现基于协议的 MVP</title>
      <link href="/2019/02/13/zai-ios-shang-shi-xian-ji-yu-xie-yi-de-mvp/"/>
      <url>/2019/02/13/zai-ios-shang-shi-xian-ji-yu-xie-yi-de-mvp/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>如果你做过 Android 开发，那你一定知道，MVP 是 Google 官方推荐的 Android 开发架构。和 iOS 一样，Android 也存在着如果代码不够规范导致 C 层(Activity)过于臃肿的问题。</p><p>对于 MVP ，Android 无论是 Java 或是 Kotlin 都是基于 Interface 来实现的。如果你学习过 Java 或者 Kotlin 就会发现，Interface 和 iOS 里的 Protocol 还是十分相似的，只是 Obj-C 的 Protocol 相比其他几个在功能上稍微弱势一点。</p><p>本篇将教大家如何在 iOS 中使用 Protocol 实现类似 Android 的 MVP 架构。本篇灵感来自以下 Blog<br><a href="https://blog.csdn.net/lmj623565791/article/details/46596109" target="_blank" rel="noopener">浅谈 MVP in Android</a><br><a href="https://juejin.im/post/58870cc2128fe1006c46e39c" target="_blank" rel="noopener">Android MVP 十分钟入门！</a></p><h1 id="Login-Demo"><a href="#Login-Demo" class="headerlink" title="Login Demo"></a>Login Demo</h1><p>这里我们以登录为例，说一下我们的需求。</p><ol><li>用户输入账号密码，点击登录时判断用户名和密码有没有输入，没有内容时提示用户输入。</li><li>本地模拟网络请求，随机返回用户登录成功或是失败。登录成功时，返回首页并显示用户名。登录失败时，显示 Error 的信息。<br><img src="https://upload-images.jianshu.io/upload_images/2568859-cdb3052db5c2bf25.gif?imageMogr2/auto-orient/strip" alt="运行效果"></li></ol><p>试想一下在传统的 MVC 中我们会如何处理，C 持有两个 <code>UITextField</code>。</p><pre class=" language-swift"><code class="language-swift"> <span class="token atrule">@IBOutlet</span> <span class="token keyword">private</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> accountTF<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span> <span class="token atrule">@IBOutlet</span> <span class="token keyword">private</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> pwdTF<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span></code></pre><p>并添加按钮点击事件</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// MARK: - 点击登录</span> <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">loginBtnDidClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>在点击事件中，判断两个 <code>UITextField</code> 的输入内容是否合法。不合法时显示 Toast，合法时发起网络请求，在成功和失败的回调中分别对 UI 做出处理。</p><p>这种方式有什么不好呢？为什么我们的 C 层写着写着就变得异常臃肿？其实很大原因是因为 C 层的职责不够明确， C 层既负责了逻辑的处理，也负责了 UI 的变化。</p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>接下来我们用 MVP 的思想优化这个 Demo。MVP 所做的事情很简单，就是将业务逻辑和视图逻辑抽象到 Protocol 中。</p><ul><li>Model: 在 iOS 的 MVC 中 Model 通常都是指数据模型，目的是方便我们进行数据的操作。但在 MVP 中 Model 除了提供数据模型外，还负责处理具体的业务逻辑，比如我们这里的登录请求。需要注意的是，在 Model 里不应当持有 View。</li><li>View: 只负责响应 UI 变化，不负责处理业务逻辑。</li><li>Presenter:  负责完成 View 于 Model 间的交互。</li></ul><p>完工以后，我们的目录是这样的，接下来开始一步步编写思路。<br><img src="https://upload-images.jianshu.io/upload_images/2568859-44d994cda7d71414.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录"></p><h1 id="定义-Model，View，Presenter-的-Protocol"><a href="#定义-Model，View，Presenter-的-Protocol" class="headerlink" title="定义 Model，View，Presenter 的 Protocol"></a>定义 Model，View，Presenter 的 Protocol</h1><h2 id="Model-Protocol"><a href="#Model-Protocol" class="headerlink" title="Model - Protocol"></a>Model - Protocol</h2><p>首先登录返回的用户信息类肯定是必不可少的</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">User</span><span class="token punctuation">:</span> <span class="token builtin">Codable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// 姓名</span>    <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>    <span class="token comment" spellcheck="true">/// 年龄</span>    <span class="token keyword">let</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">}</span></code></pre><p>其次还需要一个 业务方法 Login</p><pre class=" language-swift"><code class="language-swift">protocol <span class="token builtin">LoginModelProtocol</span><span class="token punctuation">:</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// 登录逻辑处理</span>    <span class="token keyword">func</span> <span class="token function">login</span><span class="token punctuation">(</span>account<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> pwd<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="View-Protocol"><a href="#View-Protocol" class="headerlink" title="View - Protocol"></a>View - Protocol</h2><pre class=" language-swift"><code class="language-swift">protocol <span class="token builtin">LoginViewProtocol</span><span class="token punctuation">:</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// 账号</span>    <span class="token keyword">func</span> <span class="token function">account</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span>    <span class="token comment" spellcheck="true">/// 密码</span>    <span class="token keyword">func</span> <span class="token function">password</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span>    <span class="token comment" spellcheck="true">/// 输入不合法</span>    <span class="token keyword">func</span> <span class="token function">showToast</span><span class="token punctuation">(</span><span class="token number">_</span> text<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/// 请求正在进行中</span>    <span class="token keyword">func</span> <span class="token function">showLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/// 网络请求返回, 登录成功</span>    <span class="token keyword">func</span> <span class="token function">loginSuccess</span><span class="token punctuation">(</span><span class="token number">_</span> response<span class="token punctuation">:</span> <span class="token builtin">User</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/// 网络请求返回, 登录失败</span>    <span class="token keyword">func</span> <span class="token function">loginFailure</span><span class="token punctuation">(</span><span class="token number">_</span> error<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>对于View的接口，去观察功能上的操作，然后考虑：</p><ul><li>该操作需要什么？（account, password）</li><li>该操作的结果，对应的反馈？(showToast, loginSuccess, loginFailure)</li><li>该操作过程中对应的友好的交互？(showLoading)</li></ul><h2 id="Presenter-Protocol"><a href="#Presenter-Protocol" class="headerlink" title="Presenter - Protocol"></a>Presenter - Protocol</h2><p>Presenter Protocol 作为连接 Model 和 View 的中间桥梁，需要将二者连接起来，因此他需要完成以下工作：</p><ul><li>响应登录按钮点击事件</li><li>响应不合法事件，显示提示</li><li>登录请求中</li><li>网络请求成功回调</li><li>网络请求失败回调</li></ul><p>因此，Presenter 就可以这么定义：</p><pre class=" language-swift"><code class="language-swift">protocol <span class="token builtin">LoginPresenterProtocol</span><span class="token punctuation">:</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/// 登录</span>    <span class="token keyword">func</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/// 显示提示</span>    <span class="token keyword">func</span> <span class="token function">showToast</span><span class="token punctuation">(</span><span class="token number">_</span> text<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/// 登录请求中</span>    <span class="token keyword">func</span> <span class="token function">loading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/// 网络请求返回, 登录成功</span>    <span class="token keyword">func</span> <span class="token function">loginSuccess</span><span class="token punctuation">(</span><span class="token number">_</span> response<span class="token punctuation">:</span> <span class="token builtin">User</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/// 网络请求返回, 登录失败</span>    <span class="token keyword">func</span> <span class="token function">loginFailure</span><span class="token punctuation">(</span><span class="token number">_</span> error<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h1 id="Model，View，Presenter-的具体实现"><a href="#Model，View，Presenter-的具体实现" class="headerlink" title="Model，View，Presenter 的具体实现"></a>Model，View，Presenter 的具体实现</h1><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>还记得我们刚刚所说的，在 MVP 中，Model 的工作就是完成具体的业务和逻辑操作。比如说网络请求，持久化数据增删改查等。同时Model中又不会包含任何View。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">LoginModel</span> <span class="token punctuation">{</span>    <span class="token keyword">weak</span> <span class="token keyword">var</span> present<span class="token punctuation">:</span> <span class="token builtin">LoginPresenter</span><span class="token operator">?</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>present<span class="token punctuation">:</span> <span class="token builtin">LoginPresenter</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>present <span class="token operator">=</span> present    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// MARK: - LoginModelProtocol</span><span class="token keyword">extension</span> <span class="token builtin">LoginModel</span><span class="token punctuation">:</span> <span class="token builtin">LoginModelProtocol</span> <span class="token punctuation">{</span>    <span class="token keyword">func</span> <span class="token function">login</span><span class="token punctuation">(</span>account<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">,</span> pwd<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">guard</span> <span class="token keyword">let</span> account <span class="token operator">=</span> account<span class="token punctuation">,</span> <span class="token keyword">let</span> pwd <span class="token operator">=</span> pwd <span class="token keyword">else</span> <span class="token punctuation">{</span>            present<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">showToast</span><span class="token punctuation">(</span><span class="token string">"账号密码不合法"</span><span class="token punctuation">)</span>             <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> account<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> pwd<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            present<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">showToast</span><span class="token punctuation">(</span><span class="token string">"账号密码不合法"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        present<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">loading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token builtin">Net</span><span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>account<span class="token punctuation">:</span> account<span class="token punctuation">,</span> pwd<span class="token punctuation">:</span> pwd<span class="token punctuation">,</span> success<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span>            <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span>present<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">loginSuccess</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token keyword">weak</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span>            <span class="token keyword">self</span><span class="token operator">?</span><span class="token punctuation">.</span>present<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">loginFailure</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h2><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">LoginPresenter</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> model<span class="token punctuation">:</span> <span class="token builtin">LoginModelProtocol</span><span class="token operator">?</span>    <span class="token keyword">weak</span> <span class="token keyword">var</span> view<span class="token punctuation">:</span> <span class="token builtin">LoginViewProtocol</span><span class="token operator">?</span>    <span class="token keyword">init</span><span class="token punctuation">(</span>view<span class="token punctuation">:</span> <span class="token builtin">LoginViewProtocol</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>view <span class="token operator">=</span> view        model <span class="token operator">=</span> <span class="token function">LoginModel</span><span class="token punctuation">(</span>present<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// MARK: - LoginPresenterProtocol</span><span class="token keyword">extension</span> <span class="token builtin">LoginPresenter</span><span class="token punctuation">:</span> <span class="token builtin">LoginPresenterProtocol</span> <span class="token punctuation">{</span>    <span class="token keyword">func</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        model<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>account<span class="token punctuation">:</span> view<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">account</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pwd<span class="token punctuation">:</span> view<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">password</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">loading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        view<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">showLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">loginSuccess</span><span class="token punctuation">(</span><span class="token number">_</span> response<span class="token punctuation">:</span> <span class="token builtin">User</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        view<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">loginSuccess</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">loginFailure</span><span class="token punctuation">(</span><span class="token number">_</span> error<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        view<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">loginFailure</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">showToast</span><span class="token punctuation">(</span><span class="token number">_</span> text<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        view<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">showToast</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，我们在 <code>LoginPresenter</code> 的构造方法中，同时实例化了Model 和 View，这样 Presenter 中就同时包含了两者。在 Presenter 的具体实现中，业务相关的操作由 Model 去完成（例如 Login），视图相关的操作由 View 去完成（例如获取用户输入内容等）。Presenter 只作为一个桥梁，巧妙的将 View 和 Model 的具体实现连接了起来。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>最后再看一下 View 的具体实现，也就是 Controller 的实现：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">LoginViewController</span><span class="token punctuation">:</span> <span class="token builtin">UIViewController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">var</span> present<span class="token punctuation">:</span> <span class="token builtin">LoginPresenter</span><span class="token operator">?</span>    <span class="token comment" spellcheck="true">// MARK: - IBOutlet</span>    <span class="token atrule">@IBOutlet</span> <span class="token keyword">private</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> accountTF<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span>    <span class="token atrule">@IBOutlet</span> <span class="token keyword">private</span> <span class="token keyword">weak</span> <span class="token keyword">var</span> pwdTF<span class="token punctuation">:</span> <span class="token builtin">UITextField</span><span class="token operator">!</span>    <span class="token comment" spellcheck="true">// MARK: - LifeCycle</span>    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        present <span class="token operator">=</span> <span class="token function">LoginPresenter</span><span class="token punctuation">(</span>view<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">deinit</span> <span class="token punctuation">{</span>        present<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">detachView</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"销毁----------"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// MARK: - 点击登录</span>    <span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">loginBtnDidClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        present<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// MARK: - LoginViewProtocol</span><span class="token keyword">extension</span> <span class="token builtin">LoginViewController</span><span class="token punctuation">:</span> <span class="token builtin">LoginViewProtocol</span> <span class="token punctuation">{</span>    <span class="token keyword">func</span> <span class="token function">account</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> accountTF<span class="token punctuation">.</span>text <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">password</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> pwdTF<span class="token punctuation">.</span>text <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">showLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token builtin">Toast</span><span class="token punctuation">.</span><span class="token function">loading</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">showToast</span><span class="token punctuation">(</span><span class="token number">_</span> text<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token builtin">Toast</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span>info<span class="token punctuation">:</span> text<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">loginSuccess</span><span class="token punctuation">(</span><span class="token number">_</span> response<span class="token punctuation">:</span> <span class="token builtin">User</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token builtin">Toast</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span>info<span class="token punctuation">:</span> <span class="token string">""</span>        \<span class="token punctuation">(</span>response<span class="token punctuation">.</span>name<span class="token punctuation">)</span> \n        登录成功        <span class="token string">""</span><span class="token punctuation">)</span>        <span class="token function">dismiss</span><span class="token punctuation">(</span>animated<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> completion<span class="token punctuation">:</span> <span class="token constant">nil</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">func</span> <span class="token function">loginFailure</span><span class="token punctuation">(</span><span class="token number">_</span> error<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token builtin">Toast</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span>info<span class="token punctuation">:</span> error<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>至此，我们就通过 MVP 实现了之前所设想的业务逻辑和 UI 变换分离的 C 层。</p><ul><li>Button 的 点击负责发起登录任务，但又不负责具体实现，而是由Presenter 转接给 Model 去实现</li><li>Controller 什么时候显示 Toast，什么时候跳转界面直接由 Presenter 告诉他，他只做一个 View 该做的事情</li><li>Controller 里没有任何逻辑处理，所有的逻辑处理都在 Model 中完成了</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>看到这里其实你会发现，虽然我们的业务逻辑变得清晰了。但不可避免的我们增加了更多的类和代码，这点其实非常类似于 MVVM，相比原来简单的实现，我们需要写更多的胶水代码。</p><p>但是随着项目规模的增大，代码逻辑清晰所带来的影响是非常深远的。维护低耦合，高内聚，优雅，健壮的代码不管对自己或是别人来说都是一种享受。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> MVP </tag>
            
            <tag> Design Patterns </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
